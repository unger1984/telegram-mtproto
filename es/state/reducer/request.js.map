{"version":3,"sources":["../../../src/state/reducer/request.js"],"names":["Maybe","trimType","toUID","KeyValue","TupleT","RpcApiError","ApiRequest","handleError","state","task","msgID","outID","errorObj","error","code","message","command","request","maybeGetK","chain","getRequestTuple","map","x","bimap","removeMsgID","req","deferFinal","reject","removeK","requestID","fold","stateK","tupleToState","getRequestByID","reqID","snd","tuple","traverseMaybe","fst","handleApiResp","body","resolve","resolveTask","flags","id","api","resolved","methodResult","requestWatch","action","type","tasks","payload","newState"],"mappings":"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","file":"request.js","sourcesContent":["//@flow\n\n/* eslint-disable object-shorthand */\n\n// import { Pure, liftF } from '@safareli/free'\n// import { of, Left, Right } from 'apropos'\nimport { Maybe } from 'folktale/maybe'\n\nimport type {\n  Client,\n} from '../index.h'\nimport {\n  trimType,\n} from '../helpers'\nimport {\n  type UID,\n  toUID,\n} from 'Newtype'\nimport { KeyValue, TupleT } from 'Monad'\nimport { RpcApiError } from '../../error'\nimport ApiRequest from '../../service/main/request'\n// import Config from 'ConfigProvider'\n\nimport {\n  type MessageUnit,\n} from '../../task/index.h'\n\nfunction handleError(\n  state: Client,\n  task: MessageUnit,\n  msgID: UID,\n  outID: UID\n): Client {\n  // console.log(`\\n--- request error ---\\n`, task.body)\n  // if (task.error.handled) return state\n  const errorObj = new RpcApiError(task.error.code, task.error.message)\n  const { command, request } = state\n  return command\n    .maybeGetK(outID)\n    /*:: .map(tuple => tuple.bimap(toUID, toUID)) */\n    .chain(getRequestTuple(request))\n    .map(x => x.bimap(\n      removeMsgID(command, outID),\n      req => {\n        req.deferFinal.reject(errorObj)\n        return request\n          // .removeV(req)\n          .removeK(req.requestID)\n      }\n    ))\n    .fold(\n      stateK(state),\n      tupleToState(state))\n}\n\nconst getRequestByID =\n  (request: KeyValue<UID, ApiRequest>) =>\n    (reqID: UID): Maybe<ApiRequest> =>\n      request\n        .maybeGetK(reqID)\n        .map(TupleT.snd)\n\nconst removeMsgID = (command, outID) => msgID =>\n  command\n    .removeK(msgID)\n    .removeK(outID)\n\nconst getRequestTuple =\n  request =>\n    tuple =>\n      TupleT.traverseMaybe(\n        tuple.map(getRequestByID(request))\n      )\n\nconst stateK = (state: Client) => () => state\n\nconst tupleToState = (state: Client) => tuple => ({\n  ...state,\n  command: tuple.fst(),\n  request: tuple.snd(),\n})\n\nfunction handleApiResp(\n  state: Client,\n  task: MessageUnit,\n  msgID: UID,\n  outID: UID\n): Client {\n  const { body } = task\n  if (__DEV__)\n    console.log(`\\n--- request done ---\\n`, task.body)\n  const { command, request } = state\n  return command\n    .maybeGetK(outID)\n    /*:: .map(tuple => tuple.bimap(toUID, toUID)) */\n    .chain(getRequestTuple(request))\n    .map(x => x.bimap(\n      removeMsgID(command, outID),\n      req => {\n        req.deferFinal.resolve(body)\n        return request\n          // .removeV(req)\n          .removeK(req.requestID)\n      }\n    ))\n    .fold(\n      stateK(state),\n      tupleToState(state))\n}\n\nfunction resolveTask(state: Client, task: MessageUnit): Client {\n  const { flags } = task\n  const msgID = /*:: toUID( */ task.id /*:: ) */\n  if (flags.api) {\n    if (!task.api || !task.api.resolved) {\n      if (__DEV__)\n        console.error(`Task not found!`, task)\n    }\n    if (flags.methodResult) {\n      const outID = /*:: toUID( */ task.methodResult.outID /*:: ) */\n      if (flags.error) {\n        return handleError(state, task, msgID, outID)\n      } else if (flags.body) {\n        return handleApiResp(state, task, msgID, outID)\n      }\n    }\n  }\n  return state\n}\n\nexport default function requestWatch(state: Client, action: any): Client {\n  switch (trimType(action.type)) {\n    case ('api/task done'): {\n      const tasks: MessageUnit[] = action.payload\n      let newState = state\n      for (const task of tasks) {\n        newState = resolveTask(newState, task)\n      }\n      return newState\n    }\n    default: return state\n  }\n}\n"]}