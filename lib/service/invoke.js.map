{"version":3,"sources":["../../src/service/invoke.js"],"names":["Just","makeAuthRequest","netReq","toFuture","ERR","noDC","queryReqDc","chain","dc","withDC","uid","map","networker","wrapApiCall","msg","deferred","promise","mapRej","e","defer","reject","fold","x","newThread","toFutureR","chainRej","authRequest","thread","get","bimap","console","error","message","stack","authKey","authKeyID","serverSalt","auth","salt","Error","isNothing"],"mappings":";;;;;;;AACA;;AAEA;;AAEA;;AAEA;;;;AAGA;;AAEA;;;;AACA;;;;AAEA;;AACA;;;;AAZA,IAAM,EAAEA,IAAF,mBAAN;AAFA;AAmBO,IAAMC,4CAAmBC,MAAD,IAC7B,eACGC,QADH,CACYC,IAAIC,IADhB,EACsBC,WAAWJ,MAAX,CADtB,EAEGK,KAFH,CAESC,MAAMC,OAAOP,OAAOQ,GAAd,EAAmBF,EAAnB,CAFf,EAGGG,GAHH,CAGOC,aAAaA,UAAUC,WAAV,CAAsBX,MAAtB,CAHpB,EAIGK,KAJH,CAISO,OAAO,mBAAK,MAAMA,IAAIC,QAAJ,CAAaC,OAAxB,CAJhB,EAKGC,MALH,CAKU,gBAAIC,KAAKhB,OAAOiB,KAAP,CAAaC,MAAb,CAAoBF,CAApB,CAAT,CALV,EAMGX,KANH,CAMS,MAAM,mBAAK,MAAML,OAAOiB,KAAP,CAAaH,OAAxB,CANf,CADK;;AASP,IAAMV,aAAcJ,MAAD,IACjBA,OAAOM,EAAP,CACGa,IADH,CAEI,MAAM,wBAAYnB,OAAOQ,GAAnB,CAFV,EAGIY,KAAKtB,KAAKsB,CAAL,CAHT,CADF;;AAOA,SAASb,MAAT,CAAgBC,GAAhB,EAAqBF,EAArB,EAAyB;AAEvB,MAAMe,YAAY,MAAM,6BAAcf,EAAd,EAAkBE,GAAlB,CAAxB;;;AAOA,SAAO,eACJc,SADI,CACM,sBAAUd,GAAV,EAAeF,EAAf,CADN,EAEJiB,QAFI,CARQ,MAAMC,YAAYhB,GAAZ,EAAiBF,EAAjB,CAQd,EAGJG,GAHI,CANW,MAChB,yBACGgB,MADH,CAEGC,GAFH,CAEOlB,GAFP,EAEYF,EAFZ,EAGGa,IAHH,CAGQE,SAHR,EAGmBD,KAAKA,CAHxB,CAKK,CAAP;AAID;;AAEM,IAAMI,oCAAc,CAAChB,GAAD,EAAcF,EAAd,KAAqB,0BAAKE,GAAL,EAAUF,EAAV,EAC7CqB,KAD6C,CAE5C,gBAAIX,KAAKY,QAAQC,KAAR,CAAc,YAAd,EAA4Bb,EAAEc,OAA9B,EAAuCd,EAAEe,KAAzC,CAAT,CAF4C,EAG5C,CAAC;AACCC,SADD,EACUC,SADV,EACqBC,UADrB,EACiC5B;AADjC,CAAD,MAEO;AACL6B,QAAMH,OADD;AAELI,QAAMF,UAFD;AAGL;AACA5B;AAJK,CAFP,CAH4C,CAAzC;;AAkBP,IAAMJ,MAAM;AACVC,QAAM,MAAM;AACV,MAAIkC,KAAJ,CAAU,4BAAV,CAFQ,CAEgC;AAFhC,IAGVC,YAAY;AAAE,UAAM,IAAID,KAAJ,CAAW,kCAAX,CAAN;AAAqD;AAHzD,CAAZ","file":"invoke.js","sourcesContent":["//@flow\nimport { tap } from 'ramda'\n// import { Just } from 'folktale/maybe'\nimport { Maybe } from 'apropos'\nconst { Just } = Maybe\nimport { tryP, resolve, Future, of as ofF } from 'fluture'\n\nimport Auth from './authorizer'\n\n\nimport { createThread } from './networker'\n\nimport Config from 'ConfigProvider'\nimport ApiRequest from './main/request'\n\nimport { MaybeT } from 'Monad'\nimport {\n  queryHomeDc,\n  queryKeys,\n} from '../state/query'\n\nexport const makeAuthRequest = (netReq: ApiRequest) =>\n  MaybeT\n    .toFuture(ERR.noDC, queryReqDc(netReq))\n    .chain(dc => withDC(netReq.uid, dc))\n    .map(networker => networker.wrapApiCall(netReq))\n    .chain(msg => tryP(() => msg.deferred.promise))\n    .mapRej(tap(e => netReq.defer.reject(e)))\n    .chain(() => tryP(() => netReq.defer.promise))\n\nconst queryReqDc = (netReq: ApiRequest) =>\n  netReq.dc\n    .fold(\n      () => queryHomeDc(netReq.uid),\n      x => Just(x)\n    )\n\nfunction withDC(uid, dc) {\n  const doAuth = () => authRequest(uid, dc)\n  const newThread = () => createThread( dc, uid )\n  const getThread = () =>\n    Config\n      .thread\n      .get(uid, dc)\n      .fold(newThread, x => x)\n\n  return MaybeT\n    .toFutureR(queryKeys(uid, dc))\n    .chainRej(doAuth)\n    .map(getThread)\n}\n\nexport const authRequest = (uid: string, dc) => Auth(uid, dc)\n  .bimap(\n    tap(e => console.error('Auth error', e.message, e.stack)),\n    ({\n      authKey, authKeyID, serverSalt, dc\n    }) => ({\n      auth: authKey,\n      salt: serverSalt,\n      // authKeyID,\n      dc\n    })\n  )\n\n\ndeclare class NoDCError extends Error {  }\ndeclare class NoThreadError extends Error {  }\ndeclare var typedError: <E, /*:: -*/F>(ErrorClass: Class<E>, x: F) => E\n\nconst ERR = {\n  noDC: () => /*:: typedError(NoDCError,*/\n    new Error('get Networker without dcID') /*::) */,\n  isNothing() { throw new Error(`UnsafeMaybeValue recieve nothing`) }\n}\n"]}