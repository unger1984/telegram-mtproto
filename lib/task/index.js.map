{"version":3,"sources":["../../src/task/index.js"],"names":["normalize","decrypt","log","ctx","flattenRaw","flattenMessage","processed","result","data","dc","uid","input","session","get","keys","toFuture","ERR","noKeys","map","chain","decryptor","validateDecrypt","decrypted","thread","authID","auth","rest","responseBuffer","authKeyID","authKey","thisSessionID","prevSessionID","getMsgById","response","invalidResponse","messageID","seqNo","sessionID","message","net","checkContainer","isContainer","flattenContainer","type","id","seq","raw","Array","isArray","messages","container","ids","msg_id","cont","normalizedMsgs","msg","seqno","NoSessionKeys","Error","InvalidResponse"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\n\nimport { pipe, map } from 'ramda'\nimport { encaseP, of, reject } from 'fluture'\n\nimport {\n  type PUnitList,\n\n  type RawInput,\n  type RawMessage,\n  type RawContainer,\n  type RawObject,\n  type MessageDraft,\n  type IncomingType,\n  type SystemMessage,\n  type MessageUnit,\n\n  type ᐸPatchᐳSummaryReduced,\n} from './index.h'\nimport { isApiObject } from './fixtures'\nimport parser from '../service/chain'\nimport processing from './processing'\n// import { dispatch } from 'State'\n// import { MAIN } from 'Action'\nimport { queryKeys } from '../state/query'\nimport { MaybeT } from 'Monad'\nimport Config from 'ConfigProvider'\n\nimport mergePatch from './merge-patch'\n\nimport Logger from 'mtproto-logger'\nconst log = Logger`task-index`\n\n/*::\ndeclare var inp: RawInput\ndeclare function wait<T>(data: Promise<T>): T\nconst decryptedData = wait(decrypt(inp).promise())\n\ntype NormalizeInput = typeof decryptedData\n*/\n\nexport default function normalize(ctx: NormalizeInput) {\n  const flattenRaw = flattenMessage(ctx)\n  const processed = processing(ctx, flattenRaw)\n  return { ...mergePatch(ctx, processed), ...ctx }\n}\n\n\n\nexport function decrypt({ result: { data }, dc, uid, ...input }: RawInput) {\n  const session = Config.session.get(uid, dc)\n  const keys = MaybeT.toFuture(\n    ERR.noKeys,\n    queryKeys(uid, dc)\n  )\n  return keys\n    .map(keys => ({ ...input, data, dc, uid, ...keys, session }))\n    .chain(decryptor)\n    .chain(validateDecrypt)\n    .map(decrypted => ({ ...input, dc, uid, ...decrypted }))\n}\n\nconst decryptor = ({ thread, data, uid, dc, authID, auth, session, ...rest }) =>\n  encaseP(parser, {\n    responseBuffer: data,\n    uid,\n    dc,\n    authKeyID     : authID,\n    authKey       : auth,\n    thisSessionID : session,\n    prevSessionID : thread.prevSessionID,\n    getMsgById    : thread.getMsgById,\n  })\n  .map(result => ({ ...result, thread, uid, dc, authID, auth, session, ...rest }))\n\nfunction validateDecrypt(decrypted) {\n  const { response } = decrypted\n  if (!isApiObject(response)) {\n    return reject(ERR.invalidResponse())\n  }\n  return of(decrypted)//{ ...input, ...decrypted }\n}\n\nfunction flattenMessage(input): MessageDraft[] {\n  const { messageID, seqNo, sessionID, message, response, net, thread: { uid } } = input\n  const result = checkContainer(response)\n  if (result.isContainer) return flattenContainer(input, result.data)\n  else return [{\n    type   : 'object',\n    uid,\n    id     : messageID,\n    seq    : seqNo,\n    session: sessionID,\n    dc     : message.dc,\n    raw    : result.data\n  }]\n}\n\nfunction checkContainer(response: RawMessage) {\n  if (Array.isArray(response.messages)) {\n    //$FlowIssue\n    const container: RawContainer = response\n    const result: {\n      isContainer: true,\n      data: RawContainer,\n    } = {\n      isContainer: true,\n      data       : container,\n    }\n    return result\n  } else {\n    const data: RawObject = response\n    const result: {\n      isContainer: false,\n      data: RawObject,\n    } = {\n      isContainer: false,\n      data,\n    }\n    return result\n  }\n}\n\nfunction flattenContainer(input, container: RawContainer): MessageDraft[] {\n  const { messages } = container\n  const ids = messages.map(({ msg_id }) => msg_id)\n  const session = Config.session.get(input.thread.uid, input.dc)\n  if (__DEV__)\n    console.log(`input.sessionID`, input.sessionID)\n  if (__DEV__)\n    console.log(`real session`, session)\n  const cont: MessageDraft = {\n    type: 'container',\n    id  : input.messageID,\n    seq : input.seqNo,\n    session,\n    dc  : input.message.dc,\n    raw : ids,\n  }\n  const normalizedMsgs: MessageDraft[] = messages.map(msg => ({\n    type: 'inner',\n    id  : msg.msg_id,\n    seq : msg.seqno,\n    session,\n    dc  : input.message.dc,\n    raw : msg,\n  }))\n  return [...normalizedMsgs, cont]\n}\n\nclass NoSessionKeys extends Error {  }\nclass InvalidResponse extends Error {  }\nconst ERR = {\n  noKeys: () => new NoSessionKeys('No session keys'),\n  invalidResponse: () => new InvalidResponse('Invalid decrypted response'),\n}\n"]}